function* generateSequence_2(){
    for(let i=0;i<5;i++){
        yield i;
    }
}

// generators act like iterables
let generator = generateSequence_2();
for(let val of generator){
    console.log(val);
}

let range = {
    from:1,
    to:5,
    *[Symbol.iterator](){ //shorthand for [Sy...]:function*()
        for(let value=this.from;value<=this.to;value++){
            yield value;
        }
    }
}

console.log([...range]);

// Generator Composition

function* generateSequence(start,end){
    for(let i=start;i<=end;i++) yield i;
}

function* generatePassword(){
    yield* generateSequence(48,57);
    yield* generateSequence(65,90);
    yield* generateSequence(97,122);
}

let str = '';

for(let code of generatePassword()){
    str += String.fromCharCode(code);
}

console.log(str);

function* trialfunc(){
    let result1 = yield "This is generated by the generator";
    console.log(result1);
    let result2 = yield "This is generated by the generator";
    console.log(result2);
}

let value = trialfunc();
console.log(value.next().value);
console.log(value.next("This is passed to the yield var").value);
setTimeout(() => {value.next("Hello, this took 3 seconds")},3000);

// We can throw execution for a generator mid execution

function* generatorErr() {
   let result = yield "yippee" 
}

try{
    let gen = generatorErr();
    console.log(gen.next().value);
    gen.throw(new Error("This is a test Error"));
}
catch(err){
    console.log(err.name,err.message);
}

// We can force a generator to stop execution using return

function* generatorRet(){
    yield 1;
    yield 2;
}

let gene = generatorRet();
console.log(gene.next());
console.log(gene.return(4));
console.log(gene.next());
